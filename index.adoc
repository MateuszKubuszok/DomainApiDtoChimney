= Domain, API, DTO

**Translating between layers with Chimney**

---

Mateusz Kubuszok

== About me

[%step]
* breaking things in Scala for 9 years
* a little bit of open source - including co-authoring Chimney for almost 7 years now
* blog at https://kubuszok.com[Kubuszok.com]
* niche https://leanpub.com/jvm-scala-book[Things you need to know about JVM (that matter in Scala)] ebook

[NOTE.speaker]
--
Chimney is 7 years next month
--

== Once upon a time

[%step]
* simple web backend
* Circe codecs
* Doobie (well, Slick actually)
* Protobuf and Kinesis (well, it was Avro and Postgres)

[NOTE.speaker]
--
It was long time ago, so let's use some modern stack as an example
--

=== !

Let's look at example

[NOTE.speaker]
--
example1.scala
--

=== !

It kinds works, but let add a few modifications:

[%step]
* for `creationDate` let's use `Instant``
* for `id` let's use `UUID`

[NOTE.speaker]
--
example2.scala
--

=== !

We can still improve it!

[%step]
* let's create a separate model for JSONs
* let's create a separate model for DB operations

[NOTE.speaker]
--
example3.scala
--

=== !

Could we get rid of the silly code for mapping?

=== !

YES

[NOTE.speaker]
--
example4.scala
--

== What is possible with Chimney?

=== case class to case class

[source,scala]
--
case class Source(a: Int, b: String)
case class Target(b: String, a: Int)

Source(777, "value").transformInto[Target]
// Target("value", 777)

case class Target2(b: String, a: Int, extra: Double)

Source(777, "value").into[Target2]
  .withFieldConst(_.extra, 3.14) 
  .transform // Target2("value", 777, 3.14)
--

TODO: ADT
TODO: collections
TODO: options
TODO: partials
